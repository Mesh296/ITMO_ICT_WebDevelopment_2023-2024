{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"task1/","text":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21161 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043e\u0442\u0441\u044b\u043b\u0430\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u201cHello, server\u201d. \u0421\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u043d\u0430 \u0441\u0435\u0440\u0432\u0435\u0440\u0435. \u0421\u0435\u0440\u0432\u0435\u0440 \u0432 \u043e\u0442\u0432\u0435\u0442 \u043e\u0442\u0441\u044b\u043b\u0430\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, client\u00bb. \u0421\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u0443 \u043a\u043b\u0438\u0435\u043d\u0442\u0430. \u041e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 socket. \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043f\u0440\u043e\u0442\u043e\u043a\u043e\u043b\u0430 UDP. \u0420\u0435\u0448\u0435\u043d\u0438\u0435 \u0421\u0435\u0440\u0432\u0435\u0440 import socket port = 2002 data_recv = 2048 msg_to_client = b\"Hello client!\" host = \"127.0.0.1\" def main(): #Create a UDP socket and associate it with the specified IP address and port. s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.bind((host, port)) try: while True: #Receive the data and Client address. msg, address = s.recvfrom(data_recv) print(\"Server reply to:\", address, msg.decode(\"utf-8\")) #Reply to Client s.sendto(msg_to_client, address) except KeyboardInterrupt: s.close() if __name__ == \"__main__\": main() \u041a\u043b\u0438\u0435\u043d\u0442 import socket port = 2002 data_recv = 2048 msg_to_sv = b\"Hello server!\" host = \"127.0.0.1\" def main(): s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) #associate with the specified IP address and port. s.connect((host, port)) try: #Send message to the server s.send(msg_to_sv) #Receive n bytes of data from the server msg, address = s.recvfrom(data_recv) print(msg.decode(\"utf-8\")) except KeyboardInterrupt: s.close() if __name__ == \"__main__\": main() \u0414\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0430\u0446\u0438\u044f \u0440\u0430\u0431\u043e\u0442\u044b","title":"Task 1"},{"location":"task1/#no1","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043e\u0442\u0441\u044b\u043b\u0430\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u201cHello, server\u201d. \u0421\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u043d\u0430 \u0441\u0435\u0440\u0432\u0435\u0440\u0435. \u0421\u0435\u0440\u0432\u0435\u0440 \u0432 \u043e\u0442\u0432\u0435\u0442 \u043e\u0442\u0441\u044b\u043b\u0430\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, client\u00bb. \u0421\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u0443 \u043a\u043b\u0438\u0435\u043d\u0442\u0430. \u041e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 socket. \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043f\u0440\u043e\u0442\u043e\u043a\u043e\u043b\u0430 UDP.","title":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21161"},{"location":"task1/#_1","text":"\u0421\u0435\u0440\u0432\u0435\u0440 import socket port = 2002 data_recv = 2048 msg_to_client = b\"Hello client!\" host = \"127.0.0.1\" def main(): #Create a UDP socket and associate it with the specified IP address and port. s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.bind((host, port)) try: while True: #Receive the data and Client address. msg, address = s.recvfrom(data_recv) print(\"Server reply to:\", address, msg.decode(\"utf-8\")) #Reply to Client s.sendto(msg_to_client, address) except KeyboardInterrupt: s.close() if __name__ == \"__main__\": main() \u041a\u043b\u0438\u0435\u043d\u0442 import socket port = 2002 data_recv = 2048 msg_to_sv = b\"Hello server!\" host = \"127.0.0.1\" def main(): s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) #associate with the specified IP address and port. s.connect((host, port)) try: #Send message to the server s.send(msg_to_sv) #Receive n bytes of data from the server msg, address = s.recvfrom(data_recv) print(msg.decode(\"utf-8\")) except KeyboardInterrupt: s.close() if __name__ == \"__main__\": main()","title":"\u0420\u0435\u0448\u0435\u043d\u0438\u0435"},{"location":"task1/#_2","text":"","title":"\u0414\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0430\u0446\u0438\u044f \u0440\u0430\u0431\u043e\u0442\u044b"},{"location":"task2/","text":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21162 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u0437\u0430\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u0443 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043c\u0430\u0442\u0435\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438, \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0432\u0432\u043e\u0434\u044f\u0442\u0441\u044f \u0441 \u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u044b. \u0421\u0435\u0440\u0432\u0435\u0440 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443. \u041c\u043e\u0439 \u0432\u0430\u0440\u0438\u0430\u043d\u0442, \u0441\u043e\u0433\u043b\u0430\u0441\u043d\u043e \u0441\u043f\u0438\u0441\u043a\u0443 \u0433\u0440\u0443\u043f\u043f\u044b, \u2013 \u043f\u043b\u043e\u0449\u0430\u0434\u044c \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u043e\u0433\u0440\u0430\u043c\u043c\u0430. \u0420\u0435\u0448\u0435\u043d\u0438\u0435 \u0421\u0435\u0440\u0432\u0435\u0440 import socket port = 2002 data_recv = 2048 max_pending_conn = 8 host = \"127.0.0.1\" #function to calculate the parallelogram area def calc_parallelogram_area(pair): h, b = map(int, pair.split(\" \")) return h*b def main(): #Create a TCP socket and associate it with the specified IP address and port. s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((host, port)) s.listen(max_pending_conn) try: while True: #Accept an incoming connection from the client. client, address = s.accept() #Receive n bytes of data from the server and decode it data = client.recv(port).decode(\"utf-8\") print(f\"Data recieved: \", data) result = calc_parallelogram_area(data) #Send the encoded result to client client.send(str(result).encode(\"utf-8\")) except KeyboardInterrupt: client.close() if __name__ == \"__main__\": main() \u041a\u043b\u0438\u0435\u043d\u0442 import socket port = 2002 data_recv = 2048 host = \"127.0.0.1\" print(\"Parallelogram area calculation\") def main(): while True: #input the height and the base of Parallelogram h_str = input(\"Enter height: \") b_str = input(\"Enter base: \") #check if the input are positive integer try: h = int(h_str) b = int(b_str) if h > 0 and b > 0: break else: print(\"Height and/or base is not positive integers.\") except ValueError: print(\"Invalid input. Please enter valid integer values for height and base.\") msg = (h_str+\" \"+b_str).encode(\"utf-8\") s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) try: #Send input to server s.send(msg) #Get the answer from server msg, address = s.recvfrom(data_recv) print(\"Area of parallelogram is: \", msg.decode(\"utf-8\")) except KeyboardInterrupt: s.close() if __name__ == \"__main__\": main() \u0414\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0430\u0446\u0438\u044f \u0440\u0430\u0431\u043e\u0442\u044b","title":"Task 2"},{"location":"task2/#no2","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u0437\u0430\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u0443 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043c\u0430\u0442\u0435\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438, \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0432\u0432\u043e\u0434\u044f\u0442\u0441\u044f \u0441 \u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u044b. \u0421\u0435\u0440\u0432\u0435\u0440 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443. \u041c\u043e\u0439 \u0432\u0430\u0440\u0438\u0430\u043d\u0442, \u0441\u043e\u0433\u043b\u0430\u0441\u043d\u043e \u0441\u043f\u0438\u0441\u043a\u0443 \u0433\u0440\u0443\u043f\u043f\u044b, \u2013 \u043f\u043b\u043e\u0449\u0430\u0434\u044c \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u043e\u0433\u0440\u0430\u043c\u043c\u0430.","title":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21162"},{"location":"task2/#_1","text":"\u0421\u0435\u0440\u0432\u0435\u0440 import socket port = 2002 data_recv = 2048 max_pending_conn = 8 host = \"127.0.0.1\" #function to calculate the parallelogram area def calc_parallelogram_area(pair): h, b = map(int, pair.split(\" \")) return h*b def main(): #Create a TCP socket and associate it with the specified IP address and port. s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((host, port)) s.listen(max_pending_conn) try: while True: #Accept an incoming connection from the client. client, address = s.accept() #Receive n bytes of data from the server and decode it data = client.recv(port).decode(\"utf-8\") print(f\"Data recieved: \", data) result = calc_parallelogram_area(data) #Send the encoded result to client client.send(str(result).encode(\"utf-8\")) except KeyboardInterrupt: client.close() if __name__ == \"__main__\": main() \u041a\u043b\u0438\u0435\u043d\u0442 import socket port = 2002 data_recv = 2048 host = \"127.0.0.1\" print(\"Parallelogram area calculation\") def main(): while True: #input the height and the base of Parallelogram h_str = input(\"Enter height: \") b_str = input(\"Enter base: \") #check if the input are positive integer try: h = int(h_str) b = int(b_str) if h > 0 and b > 0: break else: print(\"Height and/or base is not positive integers.\") except ValueError: print(\"Invalid input. Please enter valid integer values for height and base.\") msg = (h_str+\" \"+b_str).encode(\"utf-8\") s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) try: #Send input to server s.send(msg) #Get the answer from server msg, address = s.recvfrom(data_recv) print(\"Area of parallelogram is: \", msg.decode(\"utf-8\")) except KeyboardInterrupt: s.close() if __name__ == \"__main__\": main()","title":"\u0420\u0435\u0448\u0435\u043d\u0438\u0435"},{"location":"task2/#_2","text":"","title":"\u0414\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0430\u0446\u0438\u044f \u0440\u0430\u0431\u043e\u0442\u044b"},{"location":"task3/","text":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21163 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u0442\u0441\u044f \u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0443. \u0412 \u043e\u0442\u0432\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442 \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 http-\u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 html-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0443, \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u0441\u0435\u0440\u0432\u0435\u0440 \u043f\u043e\u0434\u0433\u0440\u0443\u0436\u0430\u0435\u0442 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 index.html. \u0420\u0435\u0448\u0435\u043d\u0438\u0435 \u0421\u0435\u0440\u0432\u0435\u0440 import socket port = 2002 data_recv = 2048 max_pending_conn = 8 host = \"127.0.0.1\" def main(): #Create a TCP socket and associate it with the specified IP address and port. s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((host, port)) s.listen(max_pending_conn) try: while True: #Accept an incoming connection from the client. client, address = s.accept() #Receive n bytes of data from the server and decode it data = client.recv(data_recv).decode(\"utf-8\") print(f\"Data recieved: \", data) # Create an HTTP response with a 200 OK code and insert the content of \"index.html\" into the response. with open(\"index.html\") as index: response_type = \"HTTP/1.1 200 OK \\n\" headers = \"Content-Type: text/html \\n\\n\" message_body = index.read() response = (response_type + headers + message_body).encode(\"utf-8\") client.send(response) except KeyboardInterrupt: client.close() if __name__ == \"__main__\": main() \u0414\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0430\u0446\u0438\u044f \u0440\u0430\u0431\u043e\u0442\u044b","title":"Task 3"},{"location":"task3/#no3","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u0442\u0441\u044f \u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0443. \u0412 \u043e\u0442\u0432\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442 \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 http-\u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 html-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0443, \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u0441\u0435\u0440\u0432\u0435\u0440 \u043f\u043e\u0434\u0433\u0440\u0443\u0436\u0430\u0435\u0442 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 index.html.","title":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21163"},{"location":"task3/#_1","text":"\u0421\u0435\u0440\u0432\u0435\u0440 import socket port = 2002 data_recv = 2048 max_pending_conn = 8 host = \"127.0.0.1\" def main(): #Create a TCP socket and associate it with the specified IP address and port. s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((host, port)) s.listen(max_pending_conn) try: while True: #Accept an incoming connection from the client. client, address = s.accept() #Receive n bytes of data from the server and decode it data = client.recv(data_recv).decode(\"utf-8\") print(f\"Data recieved: \", data) # Create an HTTP response with a 200 OK code and insert the content of \"index.html\" into the response. with open(\"index.html\") as index: response_type = \"HTTP/1.1 200 OK \\n\" headers = \"Content-Type: text/html \\n\\n\" message_body = index.read() response = (response_type + headers + message_body).encode(\"utf-8\") client.send(response) except KeyboardInterrupt: client.close() if __name__ == \"__main__\": main()","title":"\u0420\u0435\u0448\u0435\u043d\u0438\u0435"},{"location":"task3/#_2","text":"","title":"\u0414\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0430\u0446\u0438\u044f \u0440\u0430\u0431\u043e\u0442\u044b"},{"location":"task4/","text":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21163 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0434\u0432\u0443\u0445\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0438\u043b\u0438 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0433\u043e \u0447\u0430\u0442\u0430 \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0431\u0430\u043b\u043b\u043e\u0432. \u0420\u0435\u0448\u0435\u043d\u0438\u0435 \u0421\u0435\u0440\u0432\u0435\u0440 import socket import threading port = 2002 data_recv = 2048 host = \"127.0.0.1\" max_pending_conn = 8 lock = threading.Lock() #Synchronizing Threads clients_list = [] def announce(msg): global clients_list for c in clients_list: c.send(msg.encode(\"utf-8\")) #Function for handling sending messages between clients. def send_msg_handle(client, address): global clients_list while True: try: #Receive data from the client. msg = client.recv(data_recv).decode(\"utf-8\") #Check if message is null if not msg: raise Exception #Send a message from the client to all other clients. with lock: for c in clients_list: if c != client: c.send(f\"{address[1]}: {msg}\".encode(\"utf-8\")) except: tmp = clients_list clients_list = [i for i in tmp if i != client] print(f\"Client {address} has left the chat\") announce(f\"Client {address[1]} has left the chat\") break def main(): global clients_list #Create a TCP socket and associate it with the specified IP address and port. s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((host, port)) s.listen(max_pending_conn) while True: try: #Accept an incoming connection from the client. client, address = s.accept() print(f\"Client {address} has joined the chat\") announce(f\"Client {address[1]} has joined the chat\") #Add the client socket to the list of clients. with lock: clients_list.append(client) #Start a separate thread to handle sending messages between clients. threading.Thread(target=send_msg_handle, args=( client, address)).start() except KeyboardInterrupt: s.close() break if __name__ == \"__main__\": main() \u041a\u043b\u0438\u0435\u043d\u0442 import socket import threading port = 2002 data_recv = 2048 host = \"127.0.0.1\" lock = threading.Lock() #Function for handling incoming messages from the server def recv_msg_handle(client): while True: #Receive a message from the server and decode it from a byte string msg = client.recv(data_recv).decode(\"utf-8\") print(msg) def main(): #Create a TCP socket and establish a connection to the server. s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) #Create a separate thread to receive messages from the server receive_thread = threading.Thread(target=recv_msg_handle, args=(s,)) receive_thread.start() while True: try: #Read the message from the keyboard message = input() #Encoding it into bytes and send the message to the server s.send(message.encode(\"utf-8\")) except KeyboardInterrupt: s.close() break if __name__ == \"__main__\": main() \u0414\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0430\u0446\u0438\u044f \u0440\u0430\u0431\u043e\u0442\u044b","title":"Task 4"},{"location":"task4/#no3","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0434\u0432\u0443\u0445\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0438\u043b\u0438 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0433\u043e \u0447\u0430\u0442\u0430 \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0431\u0430\u043b\u043b\u043e\u0432.","title":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21163"},{"location":"task4/#_1","text":"\u0421\u0435\u0440\u0432\u0435\u0440 import socket import threading port = 2002 data_recv = 2048 host = \"127.0.0.1\" max_pending_conn = 8 lock = threading.Lock() #Synchronizing Threads clients_list = [] def announce(msg): global clients_list for c in clients_list: c.send(msg.encode(\"utf-8\")) #Function for handling sending messages between clients. def send_msg_handle(client, address): global clients_list while True: try: #Receive data from the client. msg = client.recv(data_recv).decode(\"utf-8\") #Check if message is null if not msg: raise Exception #Send a message from the client to all other clients. with lock: for c in clients_list: if c != client: c.send(f\"{address[1]}: {msg}\".encode(\"utf-8\")) except: tmp = clients_list clients_list = [i for i in tmp if i != client] print(f\"Client {address} has left the chat\") announce(f\"Client {address[1]} has left the chat\") break def main(): global clients_list #Create a TCP socket and associate it with the specified IP address and port. s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((host, port)) s.listen(max_pending_conn) while True: try: #Accept an incoming connection from the client. client, address = s.accept() print(f\"Client {address} has joined the chat\") announce(f\"Client {address[1]} has joined the chat\") #Add the client socket to the list of clients. with lock: clients_list.append(client) #Start a separate thread to handle sending messages between clients. threading.Thread(target=send_msg_handle, args=( client, address)).start() except KeyboardInterrupt: s.close() break if __name__ == \"__main__\": main() \u041a\u043b\u0438\u0435\u043d\u0442 import socket import threading port = 2002 data_recv = 2048 host = \"127.0.0.1\" lock = threading.Lock() #Function for handling incoming messages from the server def recv_msg_handle(client): while True: #Receive a message from the server and decode it from a byte string msg = client.recv(data_recv).decode(\"utf-8\") print(msg) def main(): #Create a TCP socket and establish a connection to the server. s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) #Create a separate thread to receive messages from the server receive_thread = threading.Thread(target=recv_msg_handle, args=(s,)) receive_thread.start() while True: try: #Read the message from the keyboard message = input() #Encoding it into bytes and send the message to the server s.send(message.encode(\"utf-8\")) except KeyboardInterrupt: s.close() break if __name__ == \"__main__\": main()","title":"\u0420\u0435\u0448\u0435\u043d\u0438\u0435"},{"location":"task4/#_2","text":"","title":"\u0414\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0430\u0446\u0438\u044f \u0440\u0430\u0431\u043e\u0442\u044b"},{"location":"task5/","text":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 \u21165 \u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043d\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 web-\u0441\u0435\u0440\u0432\u0435\u0440 \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 GET \u0438 POST http \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430\u043c\u0438 Python \u0438 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 socket. \u0420\u0435\u0448\u0435\u043d\u0438\u0435 http-server import socket class MyHTTPServer: #The constructor of the MyHTTPServer class. It creates a socket object and sets options for it, then binds the socket to the given address and port, and listens on that port. Additionally, it initializes a dictionary (self.grades) to store the scores. def __init__(self, host, port): self.conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.conn.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.conn.bind((host, port)) self.conn.listen(1) self.grades = {} #This function is the main loop of the server. It listens for and accepts connections from clients and calls the serve_client function to serve the client's request. def serve_forever(self): while True: client, address = self.conn.accept() self.serve_client(client) #This function reads data sent from the client, then calls the parse_request function to parse the HTTP request. def serve_client(self, client): data = client.recv(1024).decode(\"utf-8\") self.parse_request(client, data) #This function parses the HTTP request to extract the method, URL, and HTTP version. It also tries to extract parameters from the URL if any. def parse_request(self, client, data): lines = data.split(\"\\n\") method, url, version = lines[0].split() params = ( {p.split(\"=\")[0]: p.split(\"=\")[1] for p in url.split(\"?\")[1].split(\"&\")} if \"?\" in url else None ) self.handle_request(client, method, params) #This function processes the HTTP request based on the method (GET or POST) and extracted parameters. If the method is GET, it sends the score list as HTML. If the method is POST, it stores the grade into the self.grades dictionary and sends a confirmation message. def handle_request(self, client, method, params): if method == \"GET\": self.send_response(client, 200, \"OK\", self.grades_to_html()) elif method == \"POST\": discipline = params.get(\"discipline\") grade = params.get(\"grade\") self.grades[discipline] = grade self.send_response(client, 200, \"OK\", \"Grade successfully saved!\") else: self.send_response(client, 404, \"Not Found\", \"Incorrect method, try a different method.\") #This function sends an HTTP response to the client with a status code, reason, and specific content. The response is sent as an HTTP string. def send_response(self, client, code, reason, body): response = f\"HTTP/1.1 {code} {reason}\\nContent-Type: text/html\\n\\n{body}\" client.send(response.encode(\"utf-8\")) client.close() #This function creates an HTML page containing a list of grades from the self.grades dictionary. def grades_to_html(self): page = ( f\"<html><body><ul>\" f\"{''.join([f'<li>{discipline}: {grade}' for discipline, grade in self.grades.items()])}\" f\"</ul></body></html>\" ) return page def main(): host = \"127.0.0.1\" port = 2002 server = MyHTTPServer(host, port) try: server.serve_forever() except KeyboardInterrupt: server.conn.close() if __name__ == \"__main__\": main() \u0414\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0430\u0446\u0438\u044f \u0440\u0430\u0431\u043e\u0442\u044b","title":"Task 5"},{"location":"task5/#no5","text":"\u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043d\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 web-\u0441\u0435\u0440\u0432\u0435\u0440 \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 GET \u0438 POST http \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430\u043c\u0438 Python \u0438 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 socket.","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 \u21165"},{"location":"task5/#_1","text":"http-server import socket class MyHTTPServer: #The constructor of the MyHTTPServer class. It creates a socket object and sets options for it, then binds the socket to the given address and port, and listens on that port. Additionally, it initializes a dictionary (self.grades) to store the scores. def __init__(self, host, port): self.conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.conn.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.conn.bind((host, port)) self.conn.listen(1) self.grades = {} #This function is the main loop of the server. It listens for and accepts connections from clients and calls the serve_client function to serve the client's request. def serve_forever(self): while True: client, address = self.conn.accept() self.serve_client(client) #This function reads data sent from the client, then calls the parse_request function to parse the HTTP request. def serve_client(self, client): data = client.recv(1024).decode(\"utf-8\") self.parse_request(client, data) #This function parses the HTTP request to extract the method, URL, and HTTP version. It also tries to extract parameters from the URL if any. def parse_request(self, client, data): lines = data.split(\"\\n\") method, url, version = lines[0].split() params = ( {p.split(\"=\")[0]: p.split(\"=\")[1] for p in url.split(\"?\")[1].split(\"&\")} if \"?\" in url else None ) self.handle_request(client, method, params) #This function processes the HTTP request based on the method (GET or POST) and extracted parameters. If the method is GET, it sends the score list as HTML. If the method is POST, it stores the grade into the self.grades dictionary and sends a confirmation message. def handle_request(self, client, method, params): if method == \"GET\": self.send_response(client, 200, \"OK\", self.grades_to_html()) elif method == \"POST\": discipline = params.get(\"discipline\") grade = params.get(\"grade\") self.grades[discipline] = grade self.send_response(client, 200, \"OK\", \"Grade successfully saved!\") else: self.send_response(client, 404, \"Not Found\", \"Incorrect method, try a different method.\") #This function sends an HTTP response to the client with a status code, reason, and specific content. The response is sent as an HTTP string. def send_response(self, client, code, reason, body): response = f\"HTTP/1.1 {code} {reason}\\nContent-Type: text/html\\n\\n{body}\" client.send(response.encode(\"utf-8\")) client.close() #This function creates an HTML page containing a list of grades from the self.grades dictionary. def grades_to_html(self): page = ( f\"<html><body><ul>\" f\"{''.join([f'<li>{discipline}: {grade}' for discipline, grade in self.grades.items()])}\" f\"</ul></body></html>\" ) return page def main(): host = \"127.0.0.1\" port = 2002 server = MyHTTPServer(host, port) try: server.serve_forever() except KeyboardInterrupt: server.conn.close() if __name__ == \"__main__\": main()","title":"\u0420\u0435\u0448\u0435\u043d\u0438\u0435"},{"location":"task5/#_2","text":"","title":"\u0414\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0430\u0446\u0438\u044f \u0440\u0430\u0431\u043e\u0442\u044b"}]}